<!DOCTYPE html><html class="default"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>tokenizer-dsl</title><meta name="description" content="Documentation for tokenizer-dsl"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script async src="assets/search.js" id="search-script"></script></head><body><script>document.body.classList.add(localStorage.getItem("tsd-theme") || "os")</script><header><div class="tsd-page-toolbar"><div class="container"><div class="table-wrap"><div class="table-cell" id="tsd-search" data-base="."><div class="field"><label for="tsd-search-field" class="tsd-widget search no-caption">Search</label><input type="text" id="tsd-search-field"/></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">tokenizer-dsl</a></div><div class="table-cell" id="tsd-widgets"><div id="tsd-filter"><a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a><div class="tsd-filter-group"><div class="tsd-select" id="tsd-filter-visibility"><span class="tsd-select-label">All</span><ul class="tsd-select-list"><li data-value="public">Public</li><li data-value="protected">Public/Protected</li><li data-value="private" class="selected">All</li></ul></div> <input type="checkbox" id="tsd-filter-inherited" checked/><label class="tsd-widget" for="tsd-filter-inherited">Inherited</label><input type="checkbox" id="tsd-filter-externals" checked/><label class="tsd-widget" for="tsd-filter-externals">Externals</label></div></div><a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a></div></div></div></div><div class="tsd-page-title"><div class="container"><h1>tokenizer-dsl</h1></div></div></header><div class="container container-main"><div class="row"><div class="col-8 col-content"><div class="tsd-panel tsd-typography">
<a href="#tokenizer-dsl-ðŸªµ-" id="tokenizer-dsl-ðŸªµ-" style="color: inherit; text-decoration: none;">
  <h1>tokenizer-dsl ðŸªµ <a href="https://github.com/smikhalevski/tokenizer-dsl/actions/workflows/master.yml"><img src="https://github.com/smikhalevski/tokenizer-dsl/actions/workflows/master.yml/badge.svg?branch=master&event=push" alt="build"></a></h1>
</a>
<p>The API for building streaming tokenizers and lexers.</p>
<ul>
<li><a href="#performance">2Ã— faster than <code>RegExp</code>-based alternatives</a>;</li>
<li><a href="https://bundlephobia.com/result?p=tokenizer-dsl">3 kB gzipped</a> including dependencies;</li>
<li>Supports streaming out of the box;</li>
<li>No heap allocations during tokenization;</li>
</ul>
<pre><code class="language-shell"><span class="hl-1">npm install --save-prod tokenizer-dsl</span>
</code></pre>
<ul>
<li><a href="#usage">Usage</a></li>
<li><a href="#built-in-readers">Built-in readers</a><br>
<a href="#text"><code>text</code></a> <a href="#char"><code>char</code></a> <a href="#regex"><code>regex</code></a> <a href="#all"><code>all</code></a> <a href="#seq"><code>seq</code></a> <a href="#or"><code>or</code></a> <a href="#skip"><code>skip</code></a> <a href="#until"><code>until</code></a> <a href="#end"><code>end</code></a> <a href="#lookahead"><code>lookahead</code></a> <a href="#maybe"><code>maybe</code></a> <a href="#never"><code>never</code></a> <a href="#none"><code>none</code></a></li>
<li><a href="#functional-readers">Functional readers</a></li>
<li><a href="#code-generated-readers">Code-generated readers</a></li>
<li><a href="#rules">Rules</a><ul>
<li><a href="#rule-stages">Rule stages</a></li>
<li><a href="#silent-rules">Silent rules</a></li>
</ul>
</li>
<li><a href="#streaming">Streaming</a></li>
<li><a href="#context">Context</a></li>
<li><a href="#performance">Performance</a></li>
</ul>

<a href="#usage" id="usage" style="color: inherit; text-decoration: none;">
  <h1>Usage</h1>
</a>
<p>Let&#39;s consider the input string that contains lowercase-alpha strings and floating-point numbers, separated by a
semicolon and an arbitrary number of space characters:</p>
<pre><code class="language-ts"><span class="hl-6">&#39;123.456; aaa; +777; bbb; -42&#39;</span>
</code></pre>
<p>To tokenize this string we first need to describe readers that would read chars from the input string.</p>
<p>The reader for semicolons is pretty straightforward:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">all</span><span class="hl-1">, </span><span class="hl-4">char</span><span class="hl-1">, </span><span class="hl-4">text</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">semicolonReader</span><span class="hl-1"> = </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;;&#39;</span><span class="hl-1">);</span>
</code></pre>
<p>To read a sequence of whitespaces or lowercase-alpha string we would use the combination of <code>all</code> and <code>char</code> readers:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">all</span><span class="hl-1">, </span><span class="hl-4">char</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">whitespaceReader</span><span class="hl-1"> = </span><span class="hl-2">all</span><span class="hl-1">(</span><span class="hl-2">char</span><span class="hl-1">([</span><span class="hl-6">&#39; </span><span class="hl-9">\t\n\r</span><span class="hl-6">&#39;</span><span class="hl-1">]));</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">alphaReader</span><span class="hl-1"> = </span><span class="hl-2">all</span><span class="hl-1">(</span><span class="hl-2">char</span><span class="hl-1">([[</span><span class="hl-6">&#39;a&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;z&#39;</span><span class="hl-1">]]), {</span><span class="hl-4">minimumCount:</span><span class="hl-1"> </span><span class="hl-7">1</span><span class="hl-1">});</span>
</code></pre>
<p>The <code>RegExp</code> equivalent for <code>whitespaceReader</code> if <code>/[ \t\n\r]*/y</code>, and for <code>alphaReader</code> it is <code>/[a-z]+/y</code>.</p>
<p>To read a signed floating-point number we need a combination of multiple readers:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">all</span><span class="hl-1">, </span><span class="hl-4">char</span><span class="hl-1">, </span><span class="hl-4">maybe</span><span class="hl-1">, </span><span class="hl-4">or</span><span class="hl-1">, </span><span class="hl-4">seq</span><span class="hl-1">, </span><span class="hl-4">text</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">zeroReader</span><span class="hl-1"> = </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;0&#39;</span><span class="hl-1">);</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">leadingDigitReader</span><span class="hl-1"> = </span><span class="hl-2">char</span><span class="hl-1">([[</span><span class="hl-6">&#39;1&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;9&#39;</span><span class="hl-1">]]);</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">digitsReader</span><span class="hl-1"> = </span><span class="hl-2">all</span><span class="hl-1">(</span><span class="hl-2">char</span><span class="hl-1">([[</span><span class="hl-6">&#39;0&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;9&#39;</span><span class="hl-1">]]));</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">dotReader</span><span class="hl-1"> = </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;.&#39;</span><span class="hl-1">);</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">signReader</span><span class="hl-1"> = </span><span class="hl-2">char</span><span class="hl-1">([</span><span class="hl-6">&#39;+-&#39;</span><span class="hl-1">]);</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">numberReader</span><span class="hl-1"> = </span><span class="hl-2">seq</span><span class="hl-1">(</span><br/><span class="hl-1">    </span><span class="hl-10">// sign</span><br/><span class="hl-1">    </span><span class="hl-2">maybe</span><span class="hl-1">(</span><span class="hl-4">signReader</span><span class="hl-1">),</span><br/><br/><span class="hl-1">    </span><span class="hl-10">// integer</span><br/><span class="hl-1">    </span><span class="hl-2">or</span><span class="hl-1">(</span><br/><span class="hl-1">        </span><span class="hl-4">zeroReader</span><span class="hl-1">,</span><br/><span class="hl-1">        </span><span class="hl-2">seq</span><span class="hl-1">(</span><br/><span class="hl-1">            </span><span class="hl-4">leadingDigitReader</span><span class="hl-1">,</span><br/><span class="hl-1">            </span><span class="hl-4">digitsReader</span><br/><span class="hl-1">        )</span><br/><span class="hl-1">    ),</span><br/><br/><span class="hl-1">    </span><span class="hl-10">// fraction</span><br/><span class="hl-1">    </span><span class="hl-2">maybe</span><span class="hl-1">(</span><br/><span class="hl-1">        </span><span class="hl-2">seq</span><span class="hl-1">(</span><br/><span class="hl-1">            </span><span class="hl-4">dotReader</span><span class="hl-1">,</span><br/><span class="hl-1">            </span><span class="hl-4">digitsReader</span><br/><span class="hl-1">        )</span><br/><span class="hl-1">    )</span><br/><span class="hl-1">);</span>
</code></pre>
<p>This reader works the same way as <code>/[-+]?(?:0|[1-9]\d*)(?:\.\d*)?/y</code>.</p>
<p>Now, after we defined all required readers, we can declare <a href="#rules">tokenization rules</a>:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">Rule</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">semicolonRule</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1"> = {</span><br/><span class="hl-1">  </span><span class="hl-4">type:</span><span class="hl-1"> </span><span class="hl-6">&#39;SEMICOLON&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-4">semicolonReader</span><span class="hl-1">,</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">whitespaceReader</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1"> = {</span><br/><span class="hl-1">  </span><span class="hl-4">type:</span><span class="hl-1"> </span><span class="hl-6">&#39;WHITESPACE&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-4">semicolonReader</span><span class="hl-1">,</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">alphaRule</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1"> = {</span><br/><span class="hl-1">  </span><span class="hl-4">type:</span><span class="hl-1"> </span><span class="hl-6">&#39;ALPHA&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-4">alphaReader</span><span class="hl-1">,</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">numberRule</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1"> = {</span><br/><span class="hl-1">  </span><span class="hl-4">type:</span><span class="hl-1"> </span><span class="hl-6">&#39;NUMBER&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-4">numberReader</span><span class="hl-1">,</span><br/><span class="hl-1">};</span>
</code></pre>
<p><code>type</code> is the arbitrary name of the token that the rule would read from the input string. <code>type</code> can be a string,
a number, an object, or any other data type.</p>
<p><code>reader</code> is the reader that actually reads the chars from the string.</p>
<p>The next step is to create a tokenizer that uses our rules:</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">tokenize</span><span class="hl-1"> = </span><span class="hl-2">createTokenizer</span><span class="hl-1">([</span><br/><span class="hl-1">  </span><span class="hl-4">semicolonRule</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">whitespaceRule</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">alphaRule</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">numberRule</span><br/><span class="hl-1">]);</span>
</code></pre>
<p><code>createTokenizer</code> would compile a highly efficient function that applies rules to read chars from the input string.</p>
<p>As the last step, we should call a tokenizer and provide it an input and a token handler:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">TokenHandler</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">handler</span><span class="hl-1">: </span><span class="hl-3">TokenHandler</span><span class="hl-1"> = (</span><span class="hl-4">type</span><span class="hl-1">, </span><span class="hl-4">input</span><span class="hl-1">, </span><span class="hl-4">offset</span><span class="hl-1">, </span><span class="hl-4">length</span><span class="hl-1">, </span><span class="hl-4">context</span><span class="hl-1">, </span><span class="hl-4">state</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-2">log</span><span class="hl-1">(</span><span class="hl-4">type</span><span class="hl-1">, </span><span class="hl-4">input</span><span class="hl-1">.</span><span class="hl-2">substr</span><span class="hl-1">(</span><span class="hl-4">offset</span><span class="hl-1">, </span><span class="hl-4">length</span><span class="hl-1">));</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-2">tokenize</span><span class="hl-1">(</span><span class="hl-6">&#39;123.456; aaa; +777; bbb; -42&#39;</span><span class="hl-1">, </span><span class="hl-4">handler</span><span class="hl-1">);</span>
</code></pre>
<p>The console output would be:</p>
<pre><code><span class="hl-8">NUMBER</span><span class="hl-1"> </span><span class="hl-7">123.456</span><br/><span class="hl-8">SEMICOLON</span><span class="hl-1"> ;</span><br/><span class="hl-8">WHITESPACE</span><span class="hl-1">  </span><br/><span class="hl-8">ALPHA</span><span class="hl-1"> </span><span class="hl-4">aaa</span><br/><span class="hl-8">SEMICOLON</span><span class="hl-1"> ;</span><br/><span class="hl-8">WHITESPACE</span><span class="hl-1">  </span><br/><span class="hl-8">NUMBER</span><span class="hl-1"> +</span><span class="hl-7">777</span><br/><span class="hl-8">SEMICOLON</span><span class="hl-1"> ;</span><br/><span class="hl-8">WHITESPACE</span><span class="hl-1">  </span><br/><span class="hl-8">NUMBER</span><span class="hl-1"> -</span><span class="hl-7">42</span>
</code></pre>

<a href="#built-in-readers" id="built-in-readers" style="color: inherit; text-decoration: none;">
  <h1>Built-in readers</h1>
</a>

<a href="#textstring-options" id="textstring-options" style="color: inherit; text-decoration: none;">
  <h3><code>text(string, options?)</code><a name="text"></a></h3>
</a>
<p>Reads the case-sensitive substring from the input:</p>
<pre><code class="language-ts"><span class="hl-10">// Reads &#39;foo&#39;</span><br/><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1">);</span>
</code></pre>
<p>You can optionally specify that text must be case-insensitive:</p>
<pre><code class="language-ts"><span class="hl-10">// Reads &#39;bar&#39;, &#39;BAR&#39;, &#39;Bar&#39;, etc.</span><br/><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">, {</span><span class="hl-4">caseInsensitive:</span><span class="hl-1"> </span><span class="hl-0">true</span><span class="hl-1">});</span>
</code></pre>

<a href="#charchars" id="charchars" style="color: inherit; text-decoration: none;">
  <h3><code>char(chars)</code><a name="char"></a></h3>
</a>
<p>Reads a single char from the string. You should provide an array of strings, char codes or char ranges.</p>
<pre><code class="language-ts"><span class="hl-10">// Reads &#39;a&#39;, &#39;b&#39;, or &#39;c&#39;</span><br/><span class="hl-2">char</span><span class="hl-1">([</span><span class="hl-6">&#39;a&#39;</span><span class="hl-1">, </span><span class="hl-7">98</span><span class="hl-1">, </span><span class="hl-7">99</span><span class="hl-1">]);</span>
</code></pre>
<p>You can specify a set of characters as a string with multiple characters:</p>
<pre><code class="language-ts"><span class="hl-10">// Reads &#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, or &#39;\n&#39;</span><br/><span class="hl-2">char</span><span class="hl-1">([</span><span class="hl-6">&#39; </span><span class="hl-9">\t\r\n</span><span class="hl-6">&#39;</span><span class="hl-1">]);</span>
</code></pre>
<p>You can specify a pair of char codes or strings that denote a char range:</p>
<pre><code class="language-ts"><span class="hl-10">// Reads [a-zA-Z]</span><br/><span class="hl-2">char</span><span class="hl-1">([[</span><span class="hl-6">&#39;a&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;z&#39;</span><span class="hl-1">], [</span><span class="hl-7">65</span><span class="hl-1">, </span><span class="hl-7">90</span><span class="hl-1">]]);</span>
</code></pre>

<a href="#regexpattern" id="regexpattern" style="color: inherit; text-decoration: none;">
  <h3><code>regex(pattern)</code><a name="regex"></a></h3>
</a>
<p>Reads substring using the <code>RegExp</code> pattern:</p>
<pre><code class="language-ts"><span class="hl-10">// Reads &#39;0&#39;, &#39;123&#39;, etc.</span><br/><span class="hl-2">regex</span><span class="hl-1">(</span><span class="hl-11">/0</span><span class="hl-12">|</span><span class="hl-13">[</span><span class="hl-11">1-9</span><span class="hl-13">]</span><span class="hl-11">\d</span><span class="hl-14">*</span><span class="hl-11">/</span><span class="hl-0">y</span><span class="hl-1">);</span>
</code></pre>
<p>If you don&#39;t specify <code>g</code> or <code>y</code> flags on the <code>RegExp</code>, then <code>y</code> is implicitly added.</p>

<a href="#allreader-options" id="allreader-options" style="color: inherit; text-decoration: none;">
  <h3><code>all(reader, options?)</code><a name="all"></a></h3>
</a>
<p>Applies <code>reader</code> until it can read from the input:</p>
<pre><code class="language-ts"><span class="hl-10">// Reads &#39;abc&#39; from &#39;abc123&#39;</span><br/><span class="hl-2">all</span><span class="hl-1">(</span><span class="hl-2">char</span><span class="hl-1">([[</span><span class="hl-6">&#39;a&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;z&#39;</span><span class="hl-1">]]));</span>
</code></pre>
<p>You can optionally specify the number of entries the <code>reader</code> must read to consider success:</p>
<pre><code class="language-ts"><span class="hl-10">// Reads at least one digit, but not more than 10</span><br/><span class="hl-2">all</span><span class="hl-1">(</span><span class="hl-2">char</span><span class="hl-1">([[</span><span class="hl-6">&#39;0&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;9&#39;</span><span class="hl-1">]]), {</span><span class="hl-4">minimumCount:</span><span class="hl-1"> </span><span class="hl-7">1</span><span class="hl-1">, </span><span class="hl-4">maximumCount:</span><span class="hl-1"> </span><span class="hl-7">10</span><span class="hl-1">});</span>
</code></pre>

<a href="#seqreaders" id="seqreaders" style="color: inherit; text-decoration: none;">
  <h3><code>seq(...readers)</code><a name="seq"></a></h3>
</a>
<p>Applies readers one after another sequentially:</p>
<pre><code class="language-ts"><span class="hl-10">// Reads PK-XXXXX where X is 0-9</span><br/><span class="hl-2">seq</span><span class="hl-1">(</span><br/><span class="hl-1">    </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;PK-&#39;</span><span class="hl-1">),</span><br/><span class="hl-1">    </span><span class="hl-2">all</span><span class="hl-1">(</span><span class="hl-2">char</span><span class="hl-1">([[</span><span class="hl-6">&#39;0&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;9&#39;</span><span class="hl-1">]]), {</span><span class="hl-4">minimumCount:</span><span class="hl-1"> </span><span class="hl-7">5</span><span class="hl-1">, </span><span class="hl-4">maximumCount:</span><span class="hl-1"> </span><span class="hl-7">5</span><span class="hl-1">})</span><br/><span class="hl-1">);</span>
</code></pre>

<a href="#orreaders" id="orreaders" style="color: inherit; text-decoration: none;">
  <h3><code>or(...readers)</code><a name="or"></a></h3>
</a>
<p>Returns the offset returned by the first successfully applied reader:</p>
<pre><code class="language-ts"><span class="hl-10">// Reads &#39;foo&#39; or &#39;bar&#39;</span><br/><span class="hl-2">or</span><span class="hl-1">(</span><br/><span class="hl-1">    </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1">),</span><br/><span class="hl-1">    </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">)</span><br/><span class="hl-1">);</span>
</code></pre>

<a href="#skipcount" id="skipcount" style="color: inherit; text-decoration: none;">
  <h3><code>skip(count)</code><a name="skip"></a></h3>
</a>
<p>Skips the given number of chars without reading:</p>
<pre><code class="language-ts"><span class="hl-10">// Skips 5 chars </span><br/><span class="hl-2">skip</span><span class="hl-1">(</span><span class="hl-7">5</span><span class="hl-1">);</span>
</code></pre>

<a href="#untilreader-options" id="untilreader-options" style="color: inherit; text-decoration: none;">
  <h3><code>until(reader, options?)</code><a name="until"></a></h3>
</a>
<p>Repeatedly applies <code>reader</code> until it successfully reads chars from the string. If <code>reader</code> failed to read chars then
returns -1.</p>
<pre><code class="language-ts"><span class="hl-10">// Reads everything until &#39;foo&#39; exclusively</span><br/><span class="hl-2">until</span><span class="hl-1">(</span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1">));</span>
</code></pre>
<p>You can make until to read inclusively:</p>
<pre><code class="language-ts"><span class="hl-10">// Reads everything until &#39;bar&#39; inclusvely</span><br/><span class="hl-2">until</span><span class="hl-1">(</span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">), {</span><span class="hl-4">inclusive:</span><span class="hl-1"> </span><span class="hl-0">true</span><span class="hl-1">});</span>
</code></pre>
<p>For example, to read all chars up to <code>&#39;&gt;&#39;</code> or until the end of the input:</p>
<pre><code class="language-ts"><span class="hl-2">or</span><span class="hl-1">(</span><br/><span class="hl-1">    </span><span class="hl-2">until</span><span class="hl-1">(</span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;&gt;&#39;</span><span class="hl-1">), {</span><span class="hl-4">inclusive:</span><span class="hl-1"> </span><span class="hl-0">true</span><span class="hl-1">}),</span><br/><span class="hl-1">    </span><span class="hl-2">end</span><span class="hl-1">()</span><br/><span class="hl-1">);</span>
</code></pre>

<a href="#endoffset" id="endoffset" style="color: inherit; text-decoration: none;">
  <h3><code>end(offset?)</code><a name="end"></a></h3>
</a>
<p>Skips all chars until the end of the input. You can optionally provide the offset from the input end.</p>
<pre><code class="language-ts"><span class="hl-2">end</span><span class="hl-1">(-</span><span class="hl-7">1</span><span class="hl-1">);</span>
</code></pre>

<a href="#lookaheadreader" id="lookaheadreader" style="color: inherit; text-decoration: none;">
  <h3><code>lookahead(reader)</code><a name="lookahead"></a></h3>
</a>
<p>This is the same as <a href="https://www.regular-expressions.info/lookaround.html">lookahead from the regular expressions</a>. It
returns the current offset if <code>reader</code> successfully reads chars from the input at current offset.</p>
<pre><code class="language-ts"><span class="hl-10">// Reads &#39;&lt;&#39; in &#39;&lt;a&#39;</span><br/><span class="hl-2">seq</span><span class="hl-1">(</span><br/><span class="hl-1">    </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;&lt;&#39;</span><span class="hl-1">),</span><br/><span class="hl-1">    </span><span class="hl-2">lookahead</span><span class="hl-1">(</span><span class="hl-2">char</span><span class="hl-1">([[</span><span class="hl-6">&#39;a&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;z&#39;</span><span class="hl-1">]]))</span><br/><span class="hl-1">);</span>
</code></pre>

<a href="#maybereader" id="maybereader" style="color: inherit; text-decoration: none;">
  <h3><code>maybe(reader)</code><a name="maybe"></a></h3>
</a>
<p>Returns the current offset if the <code>reader</code> failed to read chars:</p>
<pre><code class="language-ts"><span class="hl-10">// Reads &#39;foo-bar&#39; and &#39;bar&#39;</span><br/><span class="hl-2">seq</span><span class="hl-1">(</span><br/><span class="hl-1">    </span><span class="hl-2">maybe</span><span class="hl-1">(</span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;foo-&#39;</span><span class="hl-1">)),</span><br/><span class="hl-1">    </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">)</span><br/><span class="hl-1">);</span>
</code></pre>

<a href="#never" id="never" style="color: inherit; text-decoration: none;">
  <h3><code>never</code></h3>
</a>
<p>The singleton reader that always returns -1.</p>

<a href="#none" id="none" style="color: inherit; text-decoration: none;">
  <h3><code>none</code></h3>
</a>
<p>The singleton reader that always returns the current offset.</p>

<a href="#functional-readers" id="functional-readers" style="color: inherit; text-decoration: none;">
  <h1>Functional readers</h1>
</a>
<p>A reader can be defined as a function that takes an <code>input</code> string, an <code>offset</code> at which it should start reading, and a
<code>context</code>. Learn more about the context in the <a href="#context">Context</a> section.</p>
<p>A reader should return the new offset that is greater or equal to <code>offset</code> if the reader has successfully read from
the <code>input</code>, or an integer less than <code>offset</code> to indicate that nothing was read.</p>
<p>Let&#39;s create a custom reader:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">Reader</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">fooReader</span><span class="hl-1">: </span><span class="hl-3">Reader</span><span class="hl-1"> = (</span><span class="hl-4">input</span><span class="hl-1">, </span><span class="hl-4">offset</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-5">return</span><span class="hl-1"> </span><span class="hl-4">input</span><span class="hl-1">.</span><span class="hl-2">startsWith</span><span class="hl-1">(</span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1">, </span><span class="hl-4">offset</span><span class="hl-1">) ? </span><span class="hl-4">offset</span><span class="hl-1"> + </span><span class="hl-7">3</span><span class="hl-1"> : -</span><span class="hl-7">1</span><span class="hl-1">;</span><br/><span class="hl-1">};</span>
</code></pre>
<p>This reader checks that the <code>input</code> string contains a substring <code>&#39;foo&#39;</code> at the <code>offset</code> and returns the new offset where
the substring ends. Or returns -1 to indicate that the reading didn&#39;t succeed.</p>
<p>We can combine <code>fooReader</code> with any built-in reader. For example, to read chars until <code>&#39;foo&#39;</code> is met:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">until</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-10">// Reads until &#39;foo&#39; substring is met</span><br/><span class="hl-2">until</span><span class="hl-1">(</span><span class="hl-4">fooReader</span><span class="hl-1">);</span>
</code></pre>

<a href="#code-generated-readers" id="code-generated-readers" style="color: inherit; text-decoration: none;">
  <h1>Code-generated readers</h1>
</a>
<p>Code generation is used to compile highly performant readers. To leverage this feature, you can define your custom
readers as a code factories.</p>
<p>Let&#39;s recreate the reader from the previous section with the codegen approach:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">Reader</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">fooReader</span><span class="hl-1">: </span><span class="hl-3">Reader</span><span class="hl-1"> = {</span><br/><br/><span class="hl-1">  </span><span class="hl-2">factory</span><span class="hl-1">(</span><span class="hl-4">inputVar</span><span class="hl-1">, </span><span class="hl-4">offsetVar</span><span class="hl-1">, </span><span class="hl-4">contextVar</span><span class="hl-1">, </span><span class="hl-4">resultVar</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-5">return</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-4">code:</span><span class="hl-1"> [</span><br/><span class="hl-1">        </span><span class="hl-4">resultVar</span><span class="hl-1">, </span><span class="hl-6">&#39;=&#39;</span><span class="hl-1">, </span><span class="hl-4">inputVar</span><span class="hl-1">, </span><span class="hl-6">&#39;.startsWith(&quot;foo&quot;,&#39;</span><span class="hl-1">, </span><span class="hl-4">offsetVar</span><span class="hl-1">, </span><span class="hl-6">&#39;)?&#39;</span><span class="hl-1">, </span><span class="hl-4">offsetVar</span><span class="hl-1">, </span><span class="hl-6">&#39;+3:-1;&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">      ]</span><br/><span class="hl-1">    };</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">};</span>
</code></pre>
<p>The <code>factory</code> function receives four input arguments that define the variables that should be used in the output code
template:</p>
<ul>
<li><code>inputVar</code> is the variable that holds the input string.</li>
<li><code>offsetVar</code> is the variable that holds the offset in the input string from which the reader must be applied.</li>
<li><code>contextVar</code> is the variable that holds the reader context. Learn more about the context in the <a href="#context">Context</a>
section.</li>
<li><code>resultVar</code> is the variable to which the reader result must be assigned.</li>
</ul>
<p>The <code>factory</code> function should return an object containing a <code>code</code> property that holds the code template and an optional
<code>bindings</code> property that holds the variable bindings.</p>
<p>To demonstrate how to use bindings, let&#39;s enhance our reader to support arbitrary strings:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">Reader</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">function</span><span class="hl-1"> </span><span class="hl-2">substring</span><span class="hl-1">(</span><span class="hl-4">str</span><span class="hl-1">: </span><span class="hl-3">string</span><span class="hl-1">): </span><span class="hl-3">Reader</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-5">return</span><span class="hl-1"> {</span><br/><br/><span class="hl-1">    </span><span class="hl-2">factory</span><span class="hl-1">(</span><span class="hl-4">inputVar</span><span class="hl-1">, </span><span class="hl-4">offsetVar</span><span class="hl-1">, </span><span class="hl-4">contextVar</span><span class="hl-1">, </span><span class="hl-4">resultVar</span><span class="hl-1">) {</span><br/><br/><span class="hl-1">      </span><span class="hl-10">// Create a variable placeholder</span><br/><span class="hl-1">      </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">strVar</span><span class="hl-1"> = </span><span class="hl-3">Symbol</span><span class="hl-1">();</span><br/><br/><span class="hl-1">      </span><span class="hl-5">return</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-4">code:</span><span class="hl-1"> [</span><br/><span class="hl-1">          </span><span class="hl-4">resultVar</span><span class="hl-1">, </span><span class="hl-6">&#39;=&#39;</span><span class="hl-1">, </span><span class="hl-4">inputVar</span><span class="hl-1">, </span><span class="hl-6">&#39;.startsWith(&#39;</span><span class="hl-1">, </span><span class="hl-4">strVar</span><span class="hl-1">, </span><span class="hl-6">&#39;,&#39;</span><span class="hl-1">, </span><span class="hl-4">offsetVar</span><span class="hl-1">, </span><span class="hl-6">&#39;)?&#39;</span><span class="hl-1">, </span><span class="hl-4">offsetVar</span><span class="hl-1">, </span><span class="hl-6">&#39;+&#39;</span><span class="hl-1">, </span><span class="hl-4">str</span><span class="hl-1">.</span><span class="hl-4">length</span><span class="hl-1">, </span><span class="hl-6">&#39;:-1;&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">        ],</span><br/><span class="hl-1">        </span><span class="hl-4">bindings:</span><span class="hl-1"> [</span><br/><span class="hl-1">          </span><span class="hl-10">// This would assign str to a strVar at runtime</span><br/><span class="hl-1">          [</span><span class="hl-4">strVar</span><span class="hl-1">, </span><span class="hl-4">str</span><span class="hl-1">]</span><br/><span class="hl-1">        ]</span><br/><span class="hl-1">      };</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  };</span><br/><span class="hl-1">}</span>
</code></pre>
<p>We can combine <code>substring</code> with any built-in reader. For example, to read all sequential substrings in the input:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">all</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-10">// Reads consequent &#39;foo&#39; substrings</span><br/><span class="hl-2">all</span><span class="hl-1">(</span><span class="hl-2">substring</span><span class="hl-1">(</span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1">));</span>
</code></pre>
<p>You can introduce custom variables inside a code template. Here is an example of a reader that reads zero-or-more lower
alpha chars from the string using a <code>for</code> loop:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">Reader</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">lowerAlphaReader</span><span class="hl-1">: </span><span class="hl-3">Reader</span><span class="hl-1"> = {</span><br/><br/><span class="hl-1">  </span><span class="hl-2">factory</span><span class="hl-1">(</span><span class="hl-4">inputVar</span><span class="hl-1">, </span><span class="hl-4">offsetVar</span><span class="hl-1">, </span><span class="hl-4">contextVar</span><span class="hl-1">, </span><span class="hl-4">resultVar</span><span class="hl-1">) {</span><br/><br/><span class="hl-1">    </span><span class="hl-10">// Create a variable placeholders</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">indexVar</span><span class="hl-1"> = </span><span class="hl-3">Symbol</span><span class="hl-1">();</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">charCodeVar</span><span class="hl-1"> = </span><span class="hl-3">Symbol</span><span class="hl-1">();</span><br/><br/><span class="hl-1">    </span><span class="hl-5">return</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-4">code:</span><span class="hl-1"> [</span><br/><br/><span class="hl-1">        </span><span class="hl-10">// Start reading from the offset</span><br/><span class="hl-1">        </span><span class="hl-6">&#39;var &#39;</span><span class="hl-1">, </span><span class="hl-4">indexVar</span><span class="hl-1">, </span><span class="hl-6">&#39;=&#39;</span><span class="hl-1">, </span><span class="hl-4">offsetVar</span><span class="hl-1">, </span><span class="hl-6">&#39;;&#39;</span><span class="hl-1">,</span><br/><br/><span class="hl-1">        </span><span class="hl-10">// Read until end of the input</span><br/><span class="hl-1">        </span><span class="hl-6">&#39;while(&#39;</span><span class="hl-1">, </span><span class="hl-4">indexVar</span><span class="hl-1">, </span><span class="hl-6">&#39;&lt;&#39;</span><span class="hl-1">, </span><span class="hl-4">inputVar</span><span class="hl-1">, </span><span class="hl-6">&#39;.length){&#39;</span><span class="hl-1">,</span><br/><br/><span class="hl-1">        </span><span class="hl-10">// Read the char code from the input</span><br/><span class="hl-1">        </span><span class="hl-6">&#39;var &#39;</span><span class="hl-1">, </span><span class="hl-4">charCodeVar</span><span class="hl-1">, </span><span class="hl-6">&#39;=&#39;</span><span class="hl-1">, </span><span class="hl-4">inputVar</span><span class="hl-1">, </span><span class="hl-6">&#39;.charCodeAt(&#39;</span><span class="hl-1">, </span><span class="hl-4">indexVar</span><span class="hl-1">, </span><span class="hl-6">&#39;);&#39;</span><span class="hl-1">,</span><br/><br/><span class="hl-1">        </span><span class="hl-10">// Abort the loop if the char code isn&#39;t a lower alpha</span><br/><span class="hl-1">        </span><span class="hl-6">&#39;if(&#39;</span><span class="hl-1">, </span><span class="hl-4">charCodeVar</span><span class="hl-1">, </span><span class="hl-6">&#39;&lt;&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;a&#39;</span><span class="hl-1">.</span><span class="hl-2">charCodeAt</span><span class="hl-1">(</span><span class="hl-7">0</span><span class="hl-1">), </span><span class="hl-6">&#39;||&#39;</span><span class="hl-1">, </span><span class="hl-4">charCodeVar</span><span class="hl-1">, </span><span class="hl-6">&#39;&gt;&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;z&#39;</span><span class="hl-1">.</span><span class="hl-2">charCodeAt</span><span class="hl-1">(</span><span class="hl-7">0</span><span class="hl-1">), </span><span class="hl-6">&#39;)&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">        </span><span class="hl-6">&#39;break;&#39;</span><span class="hl-1">,</span><br/><br/><span class="hl-1">        </span><span class="hl-10">// Otherwise, proceed to the next char</span><br/><span class="hl-1">        </span><span class="hl-6">&#39;++&#39;</span><span class="hl-1">, </span><span class="hl-4">indexVar</span><span class="hl-1">,</span><br/><span class="hl-1">        </span><span class="hl-6">&#39;}&#39;</span><span class="hl-1">,</span><br/><br/><span class="hl-1">        </span><span class="hl-10">// Return the index that was reached </span><br/><span class="hl-1">        </span><span class="hl-4">resultVar</span><span class="hl-1">, </span><span class="hl-6">&#39;=&#39;</span><span class="hl-1">, </span><span class="hl-4">indexVar</span><span class="hl-1">, </span><span class="hl-6">&#39;;&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">      ]</span><br/><span class="hl-1">    };</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">};</span>
</code></pre>
<p>You can find out more details on how codegen works in the <a href="https://github.com/smikhalevski/codedegen">codedegen</a> repo.</p>

<a href="#rules" id="rules" style="color: inherit; text-decoration: none;">
  <h1>Rules</h1>
</a>
<p>Rules define how tokens are emitted when successfully read from the input by readers.</p>
<p>The most basic rule only defines a reader:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">Rule</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">fooRule</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1"> = {</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1">)</span><br/><span class="hl-1">};</span>
</code></pre>
<p>To use a rule, create a new tokenizer:</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">tokenize</span><span class="hl-1"> = </span><span class="hl-2">createTokenizer</span><span class="hl-1">([</span><span class="hl-4">fooRule</span><span class="hl-1">]);</span>
</code></pre>
<p>Now you can read inputs that consist of any number of <code>&#39;foo&#39;</code> substrings:</p>
<pre><code class="language-ts"><span class="hl-2">tokenize</span><span class="hl-1">(</span><span class="hl-6">&#39;foofoofoo&#39;</span><span class="hl-1">, (</span><span class="hl-4">type</span><span class="hl-1">, </span><span class="hl-4">input</span><span class="hl-1">, </span><span class="hl-4">offset</span><span class="hl-1">, </span><span class="hl-4">length</span><span class="hl-1">, </span><span class="hl-4">context</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-10">// Process the token here</span><br/><span class="hl-1">});</span>
</code></pre>
<p>Most of the time you have more than one token type in your input. Here the <code>type</code> property of the rule comes handy. The
value of this property would be passed to the <code>token</code> callback of the handler.</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">Rule</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">type</span><span class="hl-1"> </span><span class="hl-3">MyTokenType</span><span class="hl-1"> = </span><span class="hl-6">&#39;FOO&#39;</span><span class="hl-1"> | </span><span class="hl-6">&#39;BAR&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-10">// You can specify token types to enhance typing</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">fooRule</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1">&lt;</span><span class="hl-3">MyTokenType</span><span class="hl-1">&gt; = {</span><br/><span class="hl-1">  </span><span class="hl-4">type:</span><span class="hl-1"> </span><span class="hl-6">&#39;FOO&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1">)</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">barRule</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1">&lt;</span><span class="hl-3">MyTokenType</span><span class="hl-1">&gt; = {</span><br/><span class="hl-1">  </span><span class="hl-4">type:</span><span class="hl-1"> </span><span class="hl-6">&#39;BAR&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">)</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">tokenize</span><span class="hl-1"> = </span><span class="hl-2">createTokenizer</span><span class="hl-1">([</span><br/><span class="hl-1">  </span><span class="hl-4">fooRule</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">barRule</span><br/><span class="hl-1">]);</span><br/><br/><span class="hl-2">tokenize</span><span class="hl-1">(</span><span class="hl-6">&#39;foofoobarfoobar&#39;</span><span class="hl-1">, (</span><span class="hl-4">type</span><span class="hl-1">, </span><span class="hl-4">input</span><span class="hl-1">, </span><span class="hl-4">offset</span><span class="hl-1">, </span><span class="hl-4">length</span><span class="hl-1">, </span><span class="hl-4">context</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-5">switch</span><span class="hl-1"> (</span><span class="hl-4">type</span><span class="hl-1">) {</span><br/><br/><span class="hl-1">    </span><span class="hl-5">case</span><span class="hl-1"> </span><span class="hl-6">&#39;FOO&#39;</span><span class="hl-1">:</span><br/><span class="hl-1">      </span><span class="hl-10">// Process the FOO token here</span><br/><span class="hl-1">      </span><span class="hl-5">break</span><span class="hl-1">;</span><br/><br/><span class="hl-1">    </span><span class="hl-5">case</span><span class="hl-1"> </span><span class="hl-6">&#39;BAR&#39;</span><span class="hl-1">:</span><br/><span class="hl-1">      </span><span class="hl-10">// Process the BAR token here</span><br/><span class="hl-1">      </span><span class="hl-5">break</span><span class="hl-1">;</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">});</span>
</code></pre>

<a href="#rule-stages" id="rule-stages" style="color: inherit; text-decoration: none;">
  <h2>Rule stages</h2>
</a>
<p>You can put rules on different stages to control how they are applied.</p>
<p>In the previous example we created a tokenizer that reads <code>&#39;foo&#39;</code> and <code>&#39;bar&#39;</code> in any order. Let&#39;s create a tokenizer
that restricts an order in which <code>&#39;foo&#39;</code> and <code>&#39;bar&#39;</code> should be met.</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">Rule</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">type</span><span class="hl-1"> </span><span class="hl-3">MyTokenType</span><span class="hl-1"> = </span><span class="hl-6">&#39;FOO&#39;</span><span class="hl-1"> | </span><span class="hl-6">&#39;BAR&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">type</span><span class="hl-1"> </span><span class="hl-3">MyStage</span><span class="hl-1"> = </span><span class="hl-6">&#39;start&#39;</span><span class="hl-1"> | </span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1"> | </span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">fooRule</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1">&lt;</span><span class="hl-3">MyTokenType</span><span class="hl-1">, </span><span class="hl-3">MyStage</span><span class="hl-1">&gt; = {</span><br/><br/><span class="hl-1">  </span><span class="hl-10">// Rule would be applied on stages &#39;start&#39; and &#39;bar&#39;</span><br/><span class="hl-1">  </span><span class="hl-4">on:</span><span class="hl-1"> [</span><span class="hl-6">&#39;start&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">],</span><br/><span class="hl-1">  </span><span class="hl-4">type:</span><span class="hl-1"> </span><span class="hl-6">&#39;FOO&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1">),</span><br/><br/><span class="hl-1">  </span><span class="hl-10">// If rule is successfully applied then tokenizer would</span><br/><span class="hl-1">  </span><span class="hl-10">// transition to the &#39;foo&#39; stage</span><br/><span class="hl-1">  </span><span class="hl-4">to:</span><span class="hl-1"> </span><span class="hl-6">&#39;foo&#39;</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">barRule</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1">&lt;</span><span class="hl-3">MyTokenType</span><span class="hl-1">, </span><span class="hl-3">MyStage</span><span class="hl-1">&gt; = {</span><br/><span class="hl-1">  </span><span class="hl-4">on:</span><span class="hl-1"> [</span><span class="hl-6">&#39;start&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1">],</span><br/><span class="hl-1">  </span><span class="hl-4">type:</span><span class="hl-1"> </span><span class="hl-6">&#39;BAR&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">),</span><br/><span class="hl-1">  </span><span class="hl-4">to:</span><span class="hl-1"> </span><span class="hl-6">&#39;bar&#39;</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">tokenize</span><span class="hl-1"> = </span><span class="hl-2">createTokenizer</span><span class="hl-1">(</span><br/><span class="hl-1">    [</span><br/><span class="hl-1">      </span><span class="hl-4">fooRule</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-4">barRule</span><br/><span class="hl-1">    ],</span><br/><br/><span class="hl-1">    </span><span class="hl-10">// Provide the initial stage</span><br/><span class="hl-1">    </span><span class="hl-6">&#39;start&#39;</span><br/><span class="hl-1">);</span>
</code></pre>
<p>This tokenizer would successfully process <code>&#39;foobarfoobar&#39;</code> but would stop on <code>&#39;foofoo&#39;</code>.</p>
<p>Rules that don&#39;t have <code>on</code> option specified are applied on all stages. To showcase this behavior, let&#39;s modify our rules
to allow <code>&#39;foo&#39;</code> and <code>&#39;bar&#39;</code> to be separated with arbitrary number of space characters.</p>
<pre><code class="language-ts"><span class="hl-0">type</span><span class="hl-1"> </span><span class="hl-3">MyTokenType</span><span class="hl-1"> = </span><span class="hl-6">&#39;FOO&#39;</span><span class="hl-1"> | </span><span class="hl-6">&#39;BAR&#39;</span><span class="hl-1"> | </span><span class="hl-6">&#39;SPACE&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">type</span><span class="hl-1"> </span><span class="hl-3">MyStage</span><span class="hl-1"> = </span><span class="hl-6">&#39;start&#39;</span><span class="hl-1"> | </span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1"> | </span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">fooRule</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1">&lt;</span><span class="hl-3">MyTokenType</span><span class="hl-1">, </span><span class="hl-3">MyStage</span><span class="hl-1">&gt; = {</span><br/><span class="hl-1">  </span><span class="hl-4">on:</span><span class="hl-1"> [</span><span class="hl-6">&#39;start&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">],</span><br/><span class="hl-1">  </span><span class="hl-4">type:</span><span class="hl-1"> </span><span class="hl-6">&#39;FOO&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1">),</span><br/><span class="hl-1">  </span><span class="hl-4">to:</span><span class="hl-1"> </span><span class="hl-6">&#39;foo&#39;</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">barRule</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1">&lt;</span><span class="hl-3">MyTokenType</span><span class="hl-1">, </span><span class="hl-3">MyStage</span><span class="hl-1">&gt; = {</span><br/><span class="hl-1">  </span><span class="hl-4">on:</span><span class="hl-1"> [</span><span class="hl-6">&#39;start&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1">],</span><br/><span class="hl-1">  </span><span class="hl-4">type:</span><span class="hl-1"> </span><span class="hl-6">&#39;BAR&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">),</span><br/><span class="hl-1">  </span><span class="hl-4">to:</span><span class="hl-1"> </span><span class="hl-6">&#39;bar&#39;</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-10">// Rule would be applied on all stages: &#39;start&#39;, &#39;foo&#39;, and &#39;bar&#39;</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">spaceReader</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1">&lt;</span><span class="hl-3">MyTokenType</span><span class="hl-1">, </span><span class="hl-3">MyStage</span><span class="hl-1">&gt; = {</span><br/><span class="hl-1">  </span><span class="hl-4">type:</span><span class="hl-1"> </span><span class="hl-6">&#39;SPACE&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-2">all</span><span class="hl-1">(</span><span class="hl-2">char</span><span class="hl-1">([</span><span class="hl-6">&#39; &#39;</span><span class="hl-1">])),</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">tokenize</span><span class="hl-1"> = </span><span class="hl-2">createTokenizer</span><span class="hl-1">(</span><br/><span class="hl-1">    [</span><br/><span class="hl-1">      </span><span class="hl-4">fooRule</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-4">barRule</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-4">spaceReader</span><br/><span class="hl-1">    ],</span><br/><span class="hl-1">    </span><span class="hl-6">&#39;start&#39;</span><br/><span class="hl-1">);</span>
</code></pre>
<p>This tokenizer would successfully process <code>&#39; foo bar foo bar &#39;</code> input.</p>
<p>You can provide a callback that returns the next stage:</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">barRule</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1">&lt;</span><span class="hl-3">MyTokenType</span><span class="hl-1">, </span><span class="hl-3">MyStage</span><span class="hl-1">&gt; = {</span><br/><span class="hl-1">  </span><span class="hl-4">on:</span><span class="hl-1"> [</span><span class="hl-6">&#39;start&#39;</span><span class="hl-1">, </span><span class="hl-6">&#39;foo&#39;</span><span class="hl-1">],</span><br/><span class="hl-1">  </span><span class="hl-4">type:</span><span class="hl-1"> </span><span class="hl-6">&#39;BAR&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-2">text</span><span class="hl-1">(</span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">),</span><br/><br/><span class="hl-1">  </span><span class="hl-2">to</span><span class="hl-1">(</span><span class="hl-4">offset</span><span class="hl-1">, </span><span class="hl-4">length</span><span class="hl-1">, </span><span class="hl-4">context</span><span class="hl-1">, </span><span class="hl-4">state</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-10">// Return the next stage</span><br/><span class="hl-1">    </span><span class="hl-5">return</span><span class="hl-1"> </span><span class="hl-6">&#39;bar&#39;</span><span class="hl-1">;</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">};</span>
</code></pre>

<a href="#silent-rules" id="silent-rules" style="color: inherit; text-decoration: none;">
  <h2>Silent rules</h2>
</a>
<p>Some tokens don&#39;t have any semantics that you want to process. In this case, you can mark rule as <code>silent</code> to prevent
token from being emitted.</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">whitespaceRule</span><span class="hl-1">: </span><span class="hl-3">Rule</span><span class="hl-1"> = {</span><br/><span class="hl-1">  </span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-2">all</span><span class="hl-1">(</span><span class="hl-2">char</span><span class="hl-1">([</span><span class="hl-6">&#39; </span><span class="hl-9">\t\r\n</span><span class="hl-6">&#39;</span><span class="hl-1">])),</span><br/><span class="hl-1">  </span><span class="hl-4">silent:</span><span class="hl-1"> </span><span class="hl-0">true</span><br/><span class="hl-1">};</span>
</code></pre>

<a href="#streaming" id="streaming" style="color: inherit; text-decoration: none;">
  <h1>Streaming</h1>
</a>
<p>Compiled tokenizer supports streaming out of the box. Let&#39;s refer to the tokenizer that we defined in
the <a href="#usage">Usage</a> chapter:</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">tokenize</span><span class="hl-1"> = </span><span class="hl-2">createTokenizer</span><span class="hl-1">([</span><br/><span class="hl-1">  </span><span class="hl-4">semicolonRule</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">whitespaceRule</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">alphaRule</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">numberRule</span><br/><span class="hl-1">]);</span>
</code></pre>
<p>We used this tokenizer in a non-streaming fashion:</p>
<pre><code class="language-ts"><span class="hl-2">tokenizer</span><span class="hl-1">(</span><span class="hl-6">&#39;123.456; aaa; +777; bbb; -42&#39;</span><span class="hl-1">, </span><span class="hl-4">handler</span><span class="hl-1">);</span>
</code></pre>
<p>If the input string comes in chunks we can use a streaming API of the tokenizer:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">TokenizerState</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokeinzer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">state</span><span class="hl-1"> = </span><span class="hl-4">tokenizer</span><span class="hl-1">.</span><span class="hl-2">write</span><span class="hl-1">(</span><span class="hl-6">&#39;123.456&#39;</span><span class="hl-1">, </span><span class="hl-4">handler</span><span class="hl-1">);</span><br/><span class="hl-4">tokenizer</span><span class="hl-1">.</span><span class="hl-2">write</span><span class="hl-1">(</span><span class="hl-6">&#39;; aaa; +77&#39;</span><span class="hl-1">, </span><span class="hl-4">handler</span><span class="hl-1">, </span><span class="hl-4">state</span><span class="hl-1">);</span><br/><span class="hl-4">tokenizer</span><span class="hl-1">.</span><span class="hl-2">write</span><span class="hl-1">(</span><span class="hl-6">&#39;7; bbb; -42&#39;</span><span class="hl-1">, </span><span class="hl-4">handler</span><span class="hl-1">, </span><span class="hl-4">state</span><span class="hl-1">);</span><br/><span class="hl-4">tokenizer</span><span class="hl-1">.</span><span class="hl-2">end</span><span class="hl-1">(</span><span class="hl-4">handler</span><span class="hl-1">, </span><span class="hl-4">state</span><span class="hl-1">);</span>
</code></pre>
<p><code>tokenizer.write</code> accepts a mutable state object that is updated as tokenization progresses. You can inspect state to
know the stage and offset at which the tokenizer finished reading tokens.</p>
<p>Streaming tokenizer emits tokens that are <em>confirmed</em>. The token is confirmed after the consequent token is
successfully read or after the <code>tokenizer.end</code> is called.</p>

<a href="#context" id="context" style="color: inherit; text-decoration: none;">
  <h1>Context</h1>
</a>
<p>Custom readers may require a custom state. You can provide the context to the tokenizer, and it would pass it to all
readers as a third argument:</p>
<pre><code class="language-ts"><span class="hl-5">import</span><span class="hl-1"> {</span><span class="hl-4">createTokenizer</span><span class="hl-1">, </span><span class="hl-4">Reader</span><span class="hl-1">} </span><span class="hl-5">from</span><span class="hl-1"> </span><span class="hl-6">&#39;tokenizer-dsl&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-10">// Define a reader that uses a context</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">fooReader</span><span class="hl-1">: </span><span class="hl-3">Reader</span><span class="hl-1">&lt;{ </span><span class="hl-4">bar</span><span class="hl-1">: </span><span class="hl-3">number</span><span class="hl-1"> }&gt; = (</span><span class="hl-4">input</span><span class="hl-1">, </span><span class="hl-4">offset</span><span class="hl-1">, </span><span class="hl-4">context</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-2">log</span><span class="hl-1">(</span><span class="hl-4">context</span><span class="hl-1">.</span><span class="hl-4">bar</span><span class="hl-1">);</span><br/><span class="hl-1">  </span><span class="hl-5">return</span><span class="hl-1"> -</span><span class="hl-7">1</span><span class="hl-1">;</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-10">// Compile a tokenizer</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-8">tokenizer</span><span class="hl-1"> = </span><span class="hl-2">createTokenizer</span><span class="hl-1">([</span><br/><span class="hl-1">  {</span><span class="hl-4">reader:</span><span class="hl-1"> </span><span class="hl-4">fooReader</span><span class="hl-1">}</span><br/><span class="hl-1">]);</span><br/><br/><span class="hl-10">// Pass the context value</span><br/><span class="hl-2">tokenizer</span><span class="hl-1">(</span><span class="hl-6">&#39;foobar&#39;</span><span class="hl-1">, </span><span class="hl-4">handler</span><span class="hl-1">, {</span><span class="hl-4">bar:</span><span class="hl-1"> </span><span class="hl-7">123</span><span class="hl-1">});</span>
</code></pre>

<a href="#performance" id="performance" style="color: inherit; text-decoration: none;">
  <h1>Performance</h1>
</a>
<p><a href="./src/test/perf.js">To run a performance test</a>, clone this repo and run <code>npm ci &amp;&amp; npm run perf</code> in the project
directory.</p>
<p>The table below shows performance comparison between tokenizer-dsl readers and <code>RegExp</code> alternatives.</p>
<p>Results are in millions of operations per second. The higher number is better.</p>
<table>
<thead>
<tr>
<th></th>
<th align="right">tokenizer-dsl</th>
<th align="right"><code>RegExp</code></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><a href="#usage">Usage example</a></td>
<td align="right">5.3</td>
<td align="right">2.5</td>
<td></td>
</tr>
<tr>
<td><code>char([&#39;abc&#39;])</code></td>
<td align="right">88.8</td>
<td align="right">58.5</td>
<td><code>/[abc]/y</code></td>
</tr>
<tr>
<td><code>char([[&#39;a&#39;, &#39;z&#39;]])</code></td>
<td align="right">88.1</td>
<td align="right">58.4</td>
<td><code>/[a-z]/y</code></td>
</tr>
<tr>
<td><code>all(char([&#39;abc&#39;]))</code></td>
<td align="right">39.7</td>
<td align="right">50.0</td>
<td><code>/[abc]*/y</code></td>
</tr>
<tr>
<td><code>all(char([&#39;abc&#39;]), {minimumCount: 2})</code></td>
<td align="right">67.1</td>
<td align="right">50.2</td>
<td><code>/[abc]{2,}/y</code></td>
</tr>
<tr>
<td><code>all(text(&#39;abc&#39;))</code></td>
<td align="right">43.0</td>
<td align="right">50.2</td>
<td><code>/(?:abc)*/y</code></td>
</tr>
<tr>
<td><code>or(text(&#39;abc&#39;), text(&#39;123&#39;))</code></td>
<td align="right">67.3</td>
<td align="right">57.1</td>
<td><code>/abc|123/y</code></td>
</tr>
<tr>
<td><code>seq(text(&#39;abc&#39;), text(&#39;123&#39;))</code></td>
<td align="right">58.8</td>
<td align="right">54.2</td>
<td><code>/abc123/y</code></td>
</tr>
<tr>
<td><code>text(&#39;abc&#39;)</code></td>
<td align="right">72.8</td>
<td align="right">57.1</td>
<td><code>/abc/y</code></td>
</tr>
<tr>
<td><code>text(&#39;abc&#39;, {caseInsensitive: true})</code></td>
<td align="right">71.1</td>
<td align="right">55.0</td>
<td><code>/abc/iy</code></td>
</tr>
<tr>
<td><code>until(char([&#39;abc&#39;]))</code></td>
<td align="right">51.5</td>
<td align="right">48.6</td>
<td><code>/[abc]/g</code></td>
</tr>
<tr>
<td><code>until(text(&#39;abc&#39;))</code></td>
<td align="right">51.0</td>
<td align="right">33.0</td>
<td><code>/(?=abc)/g</code></td>
</tr>
<tr>
<td><code>until(text(&#39;abc&#39;), {inclusive: true})</code></td>
<td align="right">51.9</td>
<td align="right">48.8</td>
<td><code>/abc/g</code></td>
</tr>
</tbody></table>
<p>Tokenizer performance comes from following implementation aspects:</p>
<ul>
<li><p>Reader combination optimizations. For example <code>until(text(&#39;abc&#39;))</code> would read case-sensitive characters from the sting
until substring <code>&#39;abc&#39;</code> is met. An analog of this is <code>/(?=abc)/</code>. Tokenizer uses <code>input.indexOf(&#39;abc&#39;)</code> for the
substring search, which is 2Ã— faster than using a regular expression.</p>
</li>
<li><p>All readers (except <code>regex</code>) rely solely on <code>String.prototype.charCodeAt</code> and <code>String.prototype.indexOf</code> methods. This
dramatically reduces memory allocations, since no strings or other objects are created on heap.</p>
</li>
<li><p>Tokenizer compiles provided rules into a single function. No call stack overhead.</p>
</li>
<li><p>Rules that share the same prefix sequence of readers, read this prefix from the input only once. So chars in the input
are accessed less frequently.</p>
</li>
</ul>
</div></div><div class="col-4 col-menu menu-sticky-wrap menu-highlight"><nav class="tsd-navigation primary"><ul><li class="current"><a href="modules.html">Exports</a></li></ul></nav><nav class="tsd-navigation secondary menu-sticky"><ul><li class="tsd-kind-interface"><a href="interfaces/AllOptions.html" class="tsd-kind-icon">All<wbr/>Options</a></li><li class="tsd-kind-interface"><a href="interfaces/ReaderCodegen.html" class="tsd-kind-icon">Reader<wbr/>Codegen</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/Rule.html" class="tsd-kind-icon">Rule</a></li><li class="tsd-kind-interface"><a href="interfaces/TextOptions.html" class="tsd-kind-icon">Text<wbr/>Options</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/Tokenizer.html" class="tsd-kind-icon">Tokenizer</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/TokenizerState.html" class="tsd-kind-icon">Tokenizer<wbr/>State</a></li><li class="tsd-kind-interface"><a href="interfaces/UntilOptions.html" class="tsd-kind-icon">Until<wbr/>Options</a></li><li class="tsd-kind-type-alias"><a href="modules.html#CharRange" class="tsd-kind-icon">Char<wbr/>Range</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#Reader" class="tsd-kind-icon">Reader</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#ReaderFunction" class="tsd-kind-icon">Reader<wbr/>Function</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#StageProvider" class="tsd-kind-icon">Stage<wbr/>Provider</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#TokenHandler" class="tsd-kind-icon">Token<wbr/>Handler</a></li><li class="tsd-kind-variable"><a href="modules.html#never" class="tsd-kind-icon">never</a></li><li class="tsd-kind-variable"><a href="modules.html#none" class="tsd-kind-icon">none</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#all" class="tsd-kind-icon">all</a></li><li class="tsd-kind-function"><a href="modules.html#char" class="tsd-kind-icon">char</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createTokenizer" class="tsd-kind-icon">create<wbr/>Tokenizer</a></li><li class="tsd-kind-function"><a href="modules.html#end" class="tsd-kind-icon">end</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#lookahead" class="tsd-kind-icon">lookahead</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#maybe" class="tsd-kind-icon">maybe</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#or" class="tsd-kind-icon">or</a></li><li class="tsd-kind-function"><a href="modules.html#regex" class="tsd-kind-icon">regex</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#seq" class="tsd-kind-icon">seq</a></li><li class="tsd-kind-function"><a href="modules.html#skip" class="tsd-kind-icon">skip</a></li><li class="tsd-kind-function"><a href="modules.html#text" class="tsd-kind-icon">text</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#toReaderFunction" class="tsd-kind-icon">to<wbr/>Reader<wbr/>Function</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#until" class="tsd-kind-icon">until</a></li></ul></nav></div></div></div><footer class="with-border-bottom"><div class="container"><h2>Legend</h2><div class="tsd-legend-group"><ul class="tsd-legend"><li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li><li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li></ul></div><h2>Settings</h2><p>Theme <select id="theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></p></div></footer><div class="container tsd-generator"><p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div><div class="overlay"></div><script src="assets/main.js"></script></body></html>